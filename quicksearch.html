<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"mailvelope-client-api.js.html":{"id":"mailvelope-client-api.js.html","title":"Source: mailvelope-client-api.js","body":" Mailvelope API Tutorials Readme Global mailvelope Source: mailvelope-client-api.js /** * The MIT License (MIT) * * Copyright (c) 2014-2015 Mailvelope GmbH * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the &quot;Software&quot;), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN * THE SOFTWARE. */ 'use strict'; (function() { /** * Not accessible, see {@tutorial Readme} instead on how to obtain access to an instance. * @constructor * @private * @alias Mailvelope */ var Mailvelope = function() {}; /** * Gives access to the mailvelope extension version * @returns {Promise.&lt;String, Error&gt;} */ Mailvelope.prototype.getVersion = function() { return postMessage('get-version'); }; /** * Retrieves the Keyring for the given identifier * @param {string} identifier - the identifier of the keyring * @returns {Promise.&lt;Keyring, Error&gt;} * @throws {Error} error.code = 'NO_KEYRING_FOR_ID' */ Mailvelope.prototype.getKeyring = function(identifier) { return postMessage('get-keyring', {identifier: identifier}).then(function(options) { return new Keyring(identifier, options); }); }; /** * Creates a Keyring for the given identifier * @param {string} identifier - the identifier of the new keyring * @returns {Promise.&lt;Keyring, Error&gt;} * @throws {Error} error.code = 'KEYRING_ALREADY_EXISTS' * @example * mailvelope.createKeyring('Account-ID-4711').then(function(keyring) { * // continue to display the settings container and start the setup wizard * mailvelope.createSettingsContainer('#mailvelope-settings', keyring); * }); */ Mailvelope.prototype.createKeyring = function(identifier) { return postMessage('create-keyring', {identifier: identifier}).then(function(options) { return new Keyring(identifier, options); }); }; var checkTypeKeyring = function(keyring) { if (!(keyring instanceof Keyring)) { var error = new Error('Type mismatch: keyring should be instance of Keyring.'); error.code = 'TYPE_MISMATCH'; throw error; } }; /** * Ascii Armored PGP Text Block * @typedef {string} AsciiArmored */ /** * CSS Selector String * @typedef {string} CssSelector */ /** * @typedef {Object} DisplayContainerOptions * @property {boolean} showExternalContent - if true loads external content into the display container (default: true) * @property {string} senderAddress - email address of sender, used to indentify key for signature verification */ /** * @typedef {Object} DisplayContainer * @property {Error} error - Error object with code and message attribute * error.code = 'DECRYPT_ERROR' - generic decrypt error * error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message * error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog * error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message */ /** * Creates an iframe to display the decrypted content of the encrypted mail. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {AsciiArmored} armored - the encrypted mail to display * @param {Keyring} keyring - the keyring to use for this operation * @param {DisplayContainerOptions} options * @returns {Promise.&lt;DisplayContainer, Error&gt;} */ Mailvelope.prototype.createDisplayContainer = function(selector, armored, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return postMessage('display-container', {selector: selector, armored: armored, identifier: keyring.identifier, options: options}).then(function(display) { if (display &amp;&amp; display.error) { display.error = mapError(display.error); } return display; }); }; /** * @typedef {Object} EditorContainerOptions * @property {number} quota - mail content (text + attachments) limit in kilobytes (default: 20480) * @property {boolean} signMsg - if true then the mail will be signed (default: false) * @property {AsciiArmored} armoredDraft - a PGP message, signed and encrypted with the primary key of the user, will be used to restore a draft in the editor * The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments * @property {string} predefinedText - text that will be added to the editor * @property {AsciiArmored} quotedMail - mail that should be quoted * @property {boolean} quotedMailIndent - if true the quoted mail will be indented (default: true) * @property {string} quotedMailHeader - header to be added before the quoted mail * @property {boolean} keepAttachments - add attachments of quotedMail to editor (default: false) */ /** * Creates an iframe with an editor for a new encrypted mail. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {Keyring} keyring - the keyring to use for this operation * @param {EditorContainerOptions} options * @returns {Promise.&lt;Editor, Error&gt;} * @throws {Error} error.code = 'WRONG_ARMORED_TYPE' - parameters of type AsciiArmored do not have the correct armor type &lt;br&gt; error.code = 'INVALID_OPTIONS' - invalid combination of options parameter * @example * mailvelope.createEditorContainer('#editor-element', keyring).then(function(editor) { * // register event handler for mail client send button * $('#mailer-send').click(function() { * // encrypt current content of editor for array of recipients * editor.encrypt(['info@mailvelope.com', 'abc@web.de']).then(function(armored) { * console.log('encrypted message', armored); * }); * }); * }); */ Mailvelope.prototype.createEditorContainer = function(selector, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return postMessage('editor-container', {selector: selector, identifier: keyring.identifier, options: options}).then(function(editorId) { return new Editor(editorId); }); }; /** * @typedef {Object} SettingsContainerOptions * @property {string} email - the email address of the current user * @property {string} fullName - the full name of the current user */ /** * Creates an iframe to display the keyring settings. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {Keyring} keyring - the keyring to use for the setup * @param {SettingsContainerOptions} options * @returns {Promise.&lt;undefined, Error&gt;} */ Mailvelope.prototype.createSettingsContainer = function(selector, keyring, options) { try { checkTypeKeyring(keyring); } catch (e) { return Promise.reject(e); } return postMessage('settings-container', {selector: selector, identifier: keyring.identifier, options: options}); }; // connection to content script is alive var connected = true; var syncHandler = null; /** * Not accessible, instance can be obtained using {@link Mailvelope#getKeyring} * or {@link Mailvelope#createKeyring}. * @constructor * @private * @alias Keyring * @param {string} identifier - the keyring identifier * @param {object} options - the options * @property {number} logoRev - revision number of the keyring logo, initial value: 0 */ var Keyring = function(identifier, options) { this.identifier = identifier; this.logoRev = options.revision || 0; }; /** * Checks for valid key in the keyring for provided email addresses * @param {Array} recipients - list of email addresses for key lookup * @return {Promise.&lt;Object, Error&gt;} an object that maps email addresses to a status or key info object (false: no valid key, {}: valid key) * @example * keyring.validKeyForAddress(['abc@web.de', 'info@mailvelope.com']).then(function(result) { * console.log(result); * // { * // 'abc@web.de': false, * // 'info@mailvelope.com': { * // keys: [ * // {fingerprint: 'f37377c39898d05ffd39157a98bbec557ce08def', lastModified: Tue May 19 2015 10:36:53 GMT+0200 (CEST)} * // ] * // } * }); */ Keyring.prototype.validKeyForAddress = function(recipients) { return postMessage('query-valid-key', {identifier: this.identifier, recipients: recipients}).then(function(keyMap) { for (var address in keyMap) { if (keyMap[address]) { keyMap[address].keys.forEach(function(key) { key.lastModified = new Date(key.lastModified); }); } } return keyMap; }); }; /** * Exports the public key as an ascii armored string. * Only keys belonging to the user (corresponding private key exists) can be exported. * @param {string} emailAddr - email address to identify the public+private key * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'NO_KEY_FOR_ADDRESS' * @example * keyring.exportOwnPublicKey('abc@web.de').then(function(armoredPublicKey) { * console.log('exportOwnPublicKey', armoredPublicKey); // prints: &quot;-----BEGIN PGP PUBLIC KEY BLOCK...&quot; * }); */ Keyring.prototype.exportOwnPublicKey = function(emailAddr) { return postMessage('export-own-pub-key', {identifier: this.identifier, emailAddr: emailAddr}); }; /** * Asks the user if they want to import the public key. * @param {AsciiArmored} armored - public key to import * @returns {Promise.&lt;String, Error&gt;} 'IMPORTED' - key has been imported &lt;br&gt; 'UPDATED' - key already in keyring, new key merged with existing key &lt;br&gt; 'INVALIDATED' - key has been updated, new status of key is 'invalid' (e.g. revoked) &lt;br&gt; 'REJECTED' - key import rejected by user * @throws {Error} error.code = 'IMPORT_ERROR' &lt;br&gt; error.code = 'WRONG_ARMORED_TYPE' */ Keyring.prototype.importPublicKey = function(armored) { return postMessage('import-pub-key', {identifier: this.identifier, armored: armored}); }; /** * Set logo for keyring. The image is persisted in Mailvelope with a revision number, * therefore the method is only required after new keyring generation or if logo and revision number changes. * @param {string} dataURL - data-URL representing the logo, max. file size: ~10KB, max. image size: 192x96px, content-type: image/png * @param {number} revision - revision number * @returns {Promise.&lt;undefined, Error&gt;} * @throws {Error} error.code = 'LOGO_INVALID' &lt;br&gt; * error.code = 'REVISION_INVALID' * @example * keyring.setLogo('data:image/png;base64,iVBORS==', 3).then(function() { * // keyring.logoRev == 3 * }).catch(function(error) { * // logo update failed * }); * */ Keyring.prototype.setLogo = function(dataURL, revision) { var that = this; return postMessage('set-logo', {identifier: this.identifier, dataURL: dataURL, revision: revision}).then(function() { that.logoRev = revision; }); }; /** * @typedef {Object} UserId * @property {string} email - the email address of the current user * @property {string} fullName - the full name of the current user */ /** * @typedef {Object} KeyGenContainerOptions * @property {Array.&lt;UserId&gt;} userIds - array of user IDs. The first entry in the array is set as the primary user ID. * @property {number} keySize - key size in bit, optional, default: 2048, valid values: 2048, 4096. */ /** * Creates an iframe to display the key generation container. * The iframe will be injected into the container identified by selector. * @param {CssSelector} selector - target container * @param {KeyGenContainerOptions} options * @returns {Promise.&lt;Generator, Error&gt;} * @throws {Error} error.code = 'INPUT_NOT_VALID' */ Keyring.prototype.createKeyGenContainer = function(selector, options) { return postMessage('key-gen-container', {selector: selector, identifier: this.identifier, options: options}).then(function(generatorId) { return new Generator(generatorId); }); }; /** * @typedef {Object} KeyBackupContainerOptions * @param {Boolean} initialSetup (default: true) */ /** * Creates an iframe to initiate the key backup process. * @param {CssSelector} selector - target container * @param {KeyBackupContainerOptions} options * @returns {Promise.&lt;KeyBackupPopup, Error&gt;} */ Keyring.prototype.createKeyBackupContainer = function(selector, options) { return postMessage('key-backup-container', {selector: selector, identifier: this.identifier, options: options}).then(function(popupId) { return new KeyBackupPopup(popupId); }); }; /** * @typedef {Object} PrivateKeyContainerOptions * @property {boolean} restorePassword (default: false) */ /** * Creates an iframe to restore the backup. * @param {CssSelector} selector - target container * @param {PrivateKeyContainerOptions} options * @returns {Promise.&lt;undefined, Error&gt;} */ Keyring.prototype.restoreBackupContainer = function(selector, options) { return postMessage('restore-backup-container', {selector: selector, identifier: this.identifier, options: options}).then(function(restoreId) { return new RestoreBackup(restoreId); }); }; /** * Check if keyring contains valid private key with given fingerprint * @param {string} fingerprint * @returns {Promise.&lt;boolean, Error&gt;} */ Keyring.prototype.hasPrivateKey = function(fingerprint) { return postMessage('has-private-key', {identifier: this.identifier, fingerprint: fingerprint}).then(function(result) { return result; }); }; /** * @typedef {Object} UploadSyncReply * @property {String} eTag - entity tag for the uploaded encrypted keyring */ /** * @typedef {Function} UploadSyncHandler * @param {Object} uploadObj - object with upload data * @param {string} uploadObj.eTag - entity tag for the uploaded encrypted keyring, or null if initial upload * @param {AsciiArmored} uploadObj.keyringMsg - encrypted keyring as PGP armored message * @returns {Promise.&lt;UploadSyncReply, Error&gt;} - if version on server has different eTag, then the promise is rejected * if server is initial and uploadObj.eTag is not null, then the promise is rejected */ /** * @typedef {Object} DownloadSyncReply * @property {AsciiArmored} keyringMsg - encrypted keyring as PGP armored message, or null if no newer version available * @property {String} eTag - entity tag for the current encrypted keyring message, or null if server is intial */ /** * @typedef {Function} DownloadSyncHandler * @param {Object} downloadObj - meta info for download * @param {string} downloadObj.eTag - entity tag for the current local keyring, or null if no local eTag * @returns {Promise.&lt;DownloadSyncReply, Error&gt;} - if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set * if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag */ /** * @typedef {Object} BackupSyncPacket * @property {AsciiArmored} backup - encrypted key backup as PGP armored message */ /** * @typedef {Function} BackupSyncHandler * @param {BackupSyncPacket} - object with backup data * @returns {Promise.&lt;undefined, Error&gt;} */ /** * @typedef {Function} RestoreSyncHandler * @returns {Promise.&lt;BackupSyncPacket, Error&gt;} */ /** * @typedef {Object} SyncHandlerObject * @property {UploadSyncHandler} uploadSync - function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the primary private key * @property {DownloadSyncHandler} downloadSync - function called by Mailvelope to download the encrypted keyring (public keys) * @property {BackupSyncHandler} backup - function called by Mailvelope to upload a symmetrically encrypted private key backup * @property {RestoreSyncHandler} restore - function called by Mailvelope to restore a private key backup */ /** * Add various functions for keyring synchronization * @param {SyncHandlerObject} syncHandlerObj * @returns {Promise.&lt;undefined, Error&gt;} */ Keyring.prototype.addSyncHandler = function(syncHandlerObj) { if (typeof syncHandlerObj.uploadSync !== typeof syncHandlerObj.downloadSync) { return Promise.reject(new Error('uploadSync and downloadSync Handler cannot be set exclusively.')); } return postMessage('add-sync-handler', {identifier: this.identifier}).then(function(syncHandlerId) { if (syncHandler) { syncHandler.update(syncHandlerObj); } else { syncHandler = new SyncHandler(syncHandlerId, syncHandlerObj); } }); }; /** * Open the extension settings in a new browser tab * @returns {Promise.&lt;undefined, Error&gt;} */ Keyring.prototype.openSettings = function() { return postMessage('open-settings', {identifier: this.identifier}); }; /** * Not accessible, instance can be obtained using {@link Keyring#createKeyBackupContainer} * @private * @param {string} popupId * @alis Popup * @constructor */ var KeyBackupPopup = function(popupId) { this.popupId = popupId; }; /** * @returns {Promise.&lt;undefined, Error&gt;} - key backup ready or error * @throws {Error} */ KeyBackupPopup.prototype.isReady = function() { return postMessage('keybackup-popup-isready', {popupId: this.popupId}); }; /** * Not accessible, instance can be obtained using {@link Keyring#createKeyGenContainer}. * @private * @param {string} generatorId - the internal id of the generator * @alias Generator * @constructor */ var Generator = function(generatorId) { this.generatorId = generatorId; }; /** * Generate a private key * @param {Promise.&lt;undefined, Error&gt;} [confirm] - newly generate key is only persisted if Promise resolves, * in the reject or timeout case the generated key is rejected * @returns {Promise.&lt;AsciiArmored, Error&gt;} - the newly generated key (public part) * @throws {Error} */ Generator.prototype.generate = function(confirm) { var that = this; return postMessage('generator-generate', {generatorId: this.generatorId, confirmRequired: Boolean(confirm)}).then(function(armored) { if (confirm) { confirm.then(function() { postMessage('generator-generate-confirm', {generatorId: that.generatorId}); }).catch(function(e) { postMessage('generator-generate-reject', {generatorId: that.generatorId, error: e}); }); } return armored; }); }; /** * Not accessible, instance can be obtained using {@link Keyring#restoreBackupContainer}. * @private * @param {string} restoreId - the internal id of the restore backup * @alias RestoreBackup * @constructor */ var RestoreBackup = function(restoreId) { this.restoreId = restoreId; }; /** * @returns {Promise.&lt;undefined, Error&gt;} - key restore ready or error * @throws {Error} */ RestoreBackup.prototype.isReady = function() { return postMessage('restore-backup-isready', {restoreId: this.restoreId}); }; /** * Not accessible, instance can be obtained using {@link Mailvelope#createEditorContainer}. * @private * @param {string} editorId - the internal id of the editor * @alias Editor * @constructor */ var Editor = function(editorId) { this.editorId = editorId; }; /** * Requests the encryption of the editor content for the given recipients. * @param {Array.&lt;string&gt;} recipients - list of email addresses for public key lookup and encryption * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br&gt; * error.code = 'NO_KEY_FOR_RECIPIENT' &lt;br&gt; * error.code = 'ENCRYPT_QUOTA_SIZE' * @example * editor.encrypt(['abc@web.de', 'info@com']).then(function (armoredMessage) { * console.log('encrypt', armoredMessage); // prints: &quot;-----BEGIN PGP MESSAGE...&quot; * } */ Editor.prototype.encrypt = function(recipients) { return postMessage('editor-encrypt', {recipients: recipients, editorId: this.editorId}); }; /** * Encrypt and sign the content of the editor with the primary key of the user. * To be used to save drafts. To restore drafts use the options.armoredDraft parameter of the createEditorContainer method. * @returns {Promise.&lt;AsciiArmored, Error&gt;} * @throws {Error} error.code = 'ENCRYPT_IN_PROGRESS' &lt;br&gt; * error.code = 'NO_KEY_FOR_ENCRYPTION' &lt;br&gt; * error.code = 'ENCRYPT_QUOTA_SIZE' */ Editor.prototype.createDraft = function() { return postMessage('editor-create-draft', {editorId: this.editorId}); }; var callbacks = Object.create(null); var SyncHandler = function(syncHandlerId, handlers) { this.syncHandlerId = syncHandlerId; this.handlers = handlers; }; SyncHandler.prototype.update = function(handlers) { for (var handle in handlers) { this.handlers[handle] = handlers[handle]; } }; function handleSyncEvent(msg) { var handler = null; switch (msg.data.type) { case 'upload': handler = syncHandler.handlers.uploadSync; break; case 'download': handler = syncHandler.handlers.downloadSync; break; case 'backup': handler = syncHandler.handlers.backup; break; case 'restore': handler = syncHandler.handlers.restore; break; default: console.log('mailvelope-client-api unknown sync event', msg.data.type); } if (!handler) { postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, error: {message: 'Sync handler not available'}, id: msg.data.id}, true); return; } handler(msg.data.data) .then(function(result) { postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, syncData: result, id: msg.data.id}, true); }) .catch(function(error) { if (!error) { error = new Error('Unknown Error'); } if (error instanceof Error || typeof error === 'string') { error = { message: error.message || String(error) }; } postMessage('sync-handler-done', {syncHandlerId: syncHandler.syncHandlerId, syncType: msg.data.type, error: error, id: msg.data.id}, true); }); } function eventListener(event) { if (event.origin !== window.location.origin || event.data.mvelo_client || !event.data.mvelo_extension) { return; } //console.log('clientAPI eventListener', event.data); switch (event.data.event) { case 'sync-event': handleSyncEvent(event.data); break; case 'callback-reply': var error; if (event.data.error) { error = new Error(event.data.error.message); error.code = event.data.error.code; if (!callbacks[event.data.id]) { throw error; } } callbacks[event.data.id](error, event.data.data); delete callbacks[event.data.id]; break; default: console.log('mailvelope-client-api unknown event', event.data.event); } } function disconnectListener() { window.removeEventListener('message', eventListener); connected = false; } function getHash() { var result = ''; var buf = new Uint16Array(6); window.crypto.getRandomValues(buf); for (var i = 0; i &lt; buf.length; i++) { result += buf[i].toString(16); } return result; } function mapError(obj) { var error = new Error(obj.message); error.code = obj.code; return error; } function postMessage(eventName, data, noResp) { if (!connected) { var error = new Error('Connection to Mailvelope extension is no longer alive.'); error.code = 'NO_CONNECTION'; throw error; } return new Promise(function(resolve, reject) { var message = { event: eventName, mvelo_client: true, data: data, id: getHash() }; if (!noResp) { callbacks[message.id] = function(err, data) { if (err) { reject(err); } else { resolve(data); } }; } window.postMessage(message, window.location.origin); }); } /** * Global instance of {@link Mailvelope} * @global * @type {Mailvelope} */ window.mailvelope = new Mailvelope(); window.addEventListener('message', eventListener); window.addEventListener('mailvelope-disconnect', disconnectListener); window.setTimeout(function() { window.dispatchEvent(new CustomEvent('mailvelope', { detail: window.mailvelope })); }, 1); }()); × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Mailvelope API Tutorials Readme Global mailvelope Global Members mailvelope :Mailvelope Global instance of Mailvelope Type: Mailvelope Source: mailvelope-client-api.js, line 686 Type Definitions AsciiArmored Ascii Armored PGP Text Block Type: string Source: mailvelope-client-api.js, line 82 BackupSyncHandler() Parameters: Type Description BackupSyncPacket object with backup data Source: mailvelope-client-api.js, line 402 Returns: Type Promise.&lt;undefined, Error&gt; BackupSyncPacket Type: Object Properties: Name Type Description backup AsciiArmored encrypted key backup as PGP armored message Source: mailvelope-client-api.js, line 397 CssSelector CSS Selector String Type: string Source: mailvelope-client-api.js, line 87 DisplayContainer Type: Object Properties: Name Type Description error Error Error object with code and message attribute error.code = 'DECRYPT_ERROR' - generic decrypt error error.code = 'ARMOR_PARSE_ERROR' - error while parsing the armored message error.code = 'PWD_DIALOG_CANCEL' - user canceled password dialog error.code = 'NO_KEY_FOUND' - no private key found to decrypt this message Source: mailvelope-client-api.js, line 98 DisplayContainerOptions Type: Object Properties: Name Type Description showExternalContent boolean if true loads external content into the display container (default: true) senderAddress string email address of sender, used to indentify key for signature verification Source: mailvelope-client-api.js, line 92 DownloadSyncHandler(downloadObj) Parameters: Name Type Description downloadObj Object meta info for download Properties Name Type Description eTag string entity tag for the current local keyring, or null if no local eTag Source: mailvelope-client-api.js, line 389 Returns: if version on server has same eTag, then keyringMsg property of reply is empty, but eTag in reply has to be set if server is initial and downloadObj.eTag is not null, then the promise is resolved with empty eTag Type Promise.&lt;DownloadSyncReply, Error&gt; DownloadSyncReply Type: Object Properties: Name Type Description keyringMsg AsciiArmored encrypted keyring as PGP armored message, or null if no newer version available eTag String entity tag for the current encrypted keyring message, or null if server is intial Source: mailvelope-client-api.js, line 383 EditorContainerOptions Type: Object Properties: Name Type Description quota number mail content (text + attachments) limit in kilobytes (default: 20480) signMsg boolean if true then the mail will be signed (default: false) armoredDraft AsciiArmored a PGP message, signed and encrypted with the primary key of the user, will be used to restore a draft in the editor The armoredDraft parameter can't be combined with the parameters: predefinedText, quotedMail... parameters, keepAttachments predefinedText string text that will be added to the editor quotedMail AsciiArmored mail that should be quoted quotedMailIndent boolean if true the quoted mail will be indented (default: true) quotedMailHeader string header to be added before the quoted mail keepAttachments boolean add attachments of quotedMail to editor (default: false) Source: mailvelope-client-api.js, line 130 KeyBackupContainerOptions Type: Object Source: mailvelope-client-api.js, line 324 KeyGenContainerOptions Type: Object Properties: Name Type Description userIds Array.&lt;UserId&gt; array of user IDs. The first entry in the array is set as the primary user ID. keySize number key size in bit, optional, default: 2048, valid values: 2048, 4096. Source: mailvelope-client-api.js, line 304 PrivateKeyContainerOptions Type: Object Properties: Name Type Description restorePassword boolean (default: false) Source: mailvelope-client-api.js, line 341 RestoreSyncHandler() Source: mailvelope-client-api.js, line 408 Returns: Type Promise.&lt;BackupSyncPacket, Error&gt; SettingsContainerOptions Type: Object Properties: Name Type Description email string the email address of the current user fullName string the full name of the current user Source: mailvelope-client-api.js, line 174 SyncHandlerObject Type: Object Properties: Name Type Description uploadSync UploadSyncHandler function called by Mailvelope to upload the keyring (public keys), the message is encrypted with the primary private key downloadSync DownloadSyncHandler function called by Mailvelope to download the encrypted keyring (public keys) backup BackupSyncHandler function called by Mailvelope to upload a symmetrically encrypted private key backup restore RestoreSyncHandler function called by Mailvelope to restore a private key backup Source: mailvelope-client-api.js, line 413 UploadSyncHandler(uploadObj) Parameters: Name Type Description uploadObj Object object with upload data Properties Name Type Description eTag string entity tag for the uploaded encrypted keyring, or null if initial upload keyringMsg AsciiArmored encrypted keyring as PGP armored message Source: mailvelope-client-api.js, line 374 Returns: if version on server has different eTag, then the promise is rejected if server is initial and uploadObj.eTag is not null, then the promise is rejected Type Promise.&lt;UploadSyncReply, Error&gt; UploadSyncReply Type: Object Properties: Name Type Description eTag String entity tag for the uploaded encrypted keyring Source: mailvelope-client-api.js, line 369 UserId Type: Object Properties: Name Type Description email string the email address of the current user fullName string the full name of the current user Source: mailvelope-client-api.js, line 298 × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Mailvelope API Tutorials Readme Global mailvelope Tutorials × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Mailvelope API Tutorials Readme Global mailvelope Basic UsageThe Mailvelope extension injects a script into the page to make its client-api accessible.The window.mailvelope object will be an instance of the Mailvelope class, please refer to its methods for further documentation. EventsmailvelopeThe event will be triggered once the window.mailvelope object is available.Since the timing is not defined consumers will have to use the following method or something equivalent to reliably obtain a reference to the Mailvelope client-API. (function() { function init() { if (typeof mailvelope !== 'undefined') { mailvelopeLoaded(); } else { window.addEventListener('mailvelope', mailvelopeLoaded, false); } } function mailvelopeLoaded() { // window.mailvelope object is available } $(document).ready(init); }());mailvelope-disconnectThe event is fired during an update of the extension. The auto-update mechanism of the browser can initiate the update at any time.Existing Mailvelope containers on a consumer page are no longer functional after the update. The disconnect event can be used to inform users about potential data loss (only relevant for Mailvelope editor) and trigger a page reload. window.addEventListener('mailvelope-disconnect', function(event) { // event.detail.version is the version of the updated extension }, false);PromisesThe client-API uses the new ECMAScript 6 Promises. At the moment JSDoc does not have specialized support for this newlanguage feature, although adding support is in discussion. Due to this reasonwe will use the @throws tag to document errors that should be expected in the rejection of a promise and will not actuallybe thrown by the function returning the promise. × Search results Close "},"tutorial-Readme.html":{"id":"tutorial-Readme.html","title":"Tutorial: Readme","body":" Mailvelope API Tutorials Readme Global mailvelope Readme Basic UsageThe Mailvelope extension injects a script into the page to make its client-api accessible.The window.mailvelope object will be an instance of the Mailvelope class, please refer to its methods for further documentation. EventsmailvelopeThe event will be triggered once the window.mailvelope object is available.Since the timing is not defined consumers will have to use the following method or something equivalent to reliably obtain a reference to the Mailvelope client-API. (function() { function init() { if (typeof mailvelope !== 'undefined') { mailvelopeLoaded(); } else { window.addEventListener('mailvelope', mailvelopeLoaded, false); } } function mailvelopeLoaded() { // window.mailvelope object is available } $(document).ready(init); }());mailvelope-disconnectThe event is fired during an update of the extension. The auto-update mechanism of the browser can initiate the update at any time.Existing Mailvelope containers on a consumer page are no longer functional after the update. The disconnect event can be used to inform users about potential data loss (only relevant for Mailvelope editor) and trigger a page reload. window.addEventListener('mailvelope-disconnect', function(event) { // event.detail.version is the version of the updated extension }, false);PromisesThe client-API uses the new ECMAScript 6 Promises. At the moment JSDoc does not have specialized support for this newlanguage feature, although adding support is in discussion. Due to this reasonwe will use the @throws tag to document errors that should be expected in the rejection of a promise and will not actuallybe thrown by the function returning the promise. × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
